---
layout: post
title:  "From NAND 2 Tetris"
date:   2016-06-11
categories: coding
published: true
future: true
---
In the past year I learned a lot of things about programming in general:

* I've had some introduction to networking
* some introduction to multithreaded programming
* object oriented programming and its paradigms
* I've had fun in different development environtments - Sublime, Eclipse, Visual Studio
* I've practiced some on Ruby, Java and C++
* learned about the existence and importance of design patterns
* had some experiences with more extensive projects

But in reality I feel as if I haven't learned much. Why is that?

### Abstractions ###

Abstractions and layering are keys to creating sophisticated but maintainable systems, and they also pave way for faster learning. I know I was able to learn high-level principles like OO programming(object oriented), because I didn't need to worry about low level stuff going on in the computer.

It helps in introducing students to programming in a way that really motivates the person.
I wouldn't want to worry about registers, about the OS, the CPU, when I want to make a snake game. I want to have fast, realtime feedback. In contrast, understanding and programming in low-level is cumbersome, error prone, slow, and many other *"negative"* things.

### Why study the low levels then? ###

You don't need to know completely how your car works if you only have to drive it from one place to another. You don't need to know which post-offices your mail has been through, it is enough to know that what you sent will be sent to where you sent it.

This is 99.9% of time for a vast majority of people. However, sometimes your car breaks down. Sometimes your mail doesn't reach its destination. In times like these at least a basic knowledge of how the given system works is beneficial.

If something breaks down, I'd rather not spend countless hours before I realise what the problem is. If one understands the computer atleast on a practical level, he can quickly find solutions to problems that are usually out of his specialty.

But I don't even need to convince you that **_someone_** has to understand the low levels, because if noone does, who's gonna design the computer? 

It also serves as a good example to see how such a complex machine as the computer comes about, through use of abstraction, layering and modules. Many projects a programmer does are too extensive to implement without a good sense of how to break them down into smaller chunks of problems. _Perhaps designing a computer will teach me more about that?..

And last but not least, just out of curiosity, I want to understand what really happens behind the scenes, when I run programs, games, load the computer, etc.

### So what can one do about it? ###

[Elements of Computing Systems][fromNand2Tetris] is a perfect resource for that, and I'm planning on investing some time on it, to build my very own computer! Prerequisites are minimal, if any at all - you need to have access to a computer, but if you're reading this, chances are you do. 

In the future, after I gather more resources and experience I may link to other projects one can do to understand computer architecture better.

[fromNand2Tetris]: "https://www.google.com"